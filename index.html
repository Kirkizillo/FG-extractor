<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Feature Graphic Extractor (w1024)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html { scroll-behavior: smooth; }
    .fade-in { animation: fade 0.4s ease-in-out; }
    @keyframes fade { from { opacity: 0; transform: translateY(4px);} to { opacity: 1; transform: translateY(0);} }
  </style>
</head>
<body class="bg-slate-950 text-slate-100 min-h-screen">
  <div class="max-w-3xl mx-auto px-4 py-10">
    <header class="mb-8">
      <h1 class="text-3xl font-bold tracking-tight">Feature Graphic Extractor <span class="text-slate-400">(w1024)</span></h1>
    </header>

    <section class="bg-slate-900/50 border border-slate-800 rounded-2xl p-5 shadow-xl">
      <div class="grid gap-3 mt-6">
        <label class="text-sm text-slate-300" for="input">Gplay URL or package ID:</label>
        <div class="flex gap-2">
          <input id="input" type="text" placeholder="https://play.google.com/store/apps/details?id=com.example or com.example" class="flex-1 rounded-xl bg-slate-900 border border-slate-800 px-4 py-3 outline-none focus:ring-2 focus:ring-indigo-500" />
          <button id="go" class="rounded-xl px-4 py-3 bg-indigo-600 hover:bg-indigo-500 active:bg-indigo-700 transition text-white font-medium">Extract</button>
        </div>
        <div class="flex items-center gap-3 mt-1">
          <label class="flex items-center gap-2 text-sm text-slate-300">
            <input id="keep169" type="checkbox" class="accent-indigo-500" /> Keep 16:9 height (<code>=w1024-h576-rw</code>)
          </label>
        </div>
      </div>

      <div id="status" class="mt-4 text-sm text-slate-400"></div>
    </section>

    <section id="result" class="hidden mt-8 fade-in">
      <div class="bg-slate-900/50 border border-slate-800 rounded-2xl p-5">
        <h2 class="text-lg font-semibold mb-3">Result</h2>
        <div class="grid gap-3">
          <div class="flex gap-2">
            <input id="outUrl" class="flex-1 rounded-xl bg-slate-900 border border-slate-800 px-3 py-2 text-sm" readonly />
            <button id="copyUrl" class="rounded-xl px-3 py-2 bg-slate-800 hover:bg-slate-700 text-sm">Copy URL</button>
          </div>
          <div class="mt-3">
            <img id="preview" alt="Feature graphic preview" class="w-full max-w-2xl rounded-xl border border-slate-800" />
            <div class="mt-2 flex gap-3 text-xs text-slate-400">
              <span id="meta"></span>
              <a id="openRaw" target="_blank" rel="noopener" class="underline">Open image in new tab</a>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

<script>
// --- Constants -----------------------------------------------------------
const IMG_HOST = "play-lh.googleusercontent.com";
const SIZE_RE = /=w(\d+)-h(\d+)/;
const FAV_HEIGHTS = new Set([405, 470, 576]); // heights commonly used by feature graphics

// --- Helpers -------------------------------------------------------------
function normalizeW1024(u, keep) {
  if (!u || !u.includes(IMG_HOST)) return u;
  const base = u.split("=")[0];
  return keep ? `${base}=w1024-h576-rw` : `${base}=w1024`;
}

function extractWH(url) {
  const m = url.match(SIZE_RE);
  if (!m) return null;
  const w = parseInt(m[1], 10), h = parseInt(m[2], 10);
  return { w, h, ratio: h ? w / h : null };
}

function uniqueInOrder(arr) {
  const seen = new Set();
  const out = [];
  for (const x of arr) if (!seen.has(x)) { seen.add(x); out.push(x); }
  return out;
}

function getPackageId(input) {
  const trimmed = input.trim();
  if (!trimmed) return null;
  try {
    const u = new URL(trimmed);
    if (u.hostname.includes('play.google.com')) {
      const id = new URLSearchParams(u.search).get('id');
      return id || null;
    }
    return null;
  } catch {
    return trimmed;
  }
}

function buildPlayUrl(pkg) {
  const params = new URLSearchParams({ id: pkg, hl: 'en', gl: 'US' });
  return `https://play.google.com/store/apps/details?${params.toString()}`;
}

// Parse ALL occurrences, including inline JSON blobs (feature graphic often lives there)
function extractImageUrlsFromHtml(html) {
  const urls = [];

  // 1) Any raw occurrences in the entire HTML (scripts + markup)
  const rawRe = /https:\/\/play-lh\.googleusercontent\.com\/[A-Za-z0-9_\-][^"'<>\s]*/g;
  const rawMatches = html.match(rawRe) || [];
  urls.push(...rawMatches);

  // 2) Also consider <img ... src/srcset> to keep order diversity (not strictly necessary, but cheap)
  const imgSrcRegex = /<img[^>]+(src|data-src|srcset)=("|')([^"']+)(\2)/gi;
  let m;
  while ((m = imgSrcRegex.exec(html)) !== null) {
    const val = m[3];
    if (val.includes(IMG_HOST)) {
      if (m[1] === 'srcset') {
        val.split(',').forEach(p => {
          const u = p.trim().split(' ')[0];
          if (u.startsWith('https://') && u.includes(IMG_HOST)) urls.push(u);
        });
      } else {
        urls.push(val);
      }
    }
  }

  return uniqueInOrder(urls);
}

// --- Scoring: target the hidden feature graphic rather than visible gallery ---
function scoreCandidate(u) {
  const s = extractWH(u);
  if (!s || !s.ratio) return -Infinity;

  // Must be landscape and close to 16:9
  if (s.w <= s.h) return -Infinity;
  const dev = Math.abs(s.ratio - (16/9));
  if (dev > 0.12) return -Infinity; // too far from 16:9

  let score = 0;

  // Closer to 16:9 is better
  if (dev <= 0.03) score += 6; else score += 3;

  // Strongly prefer known banner heights
  if (FAV_HEIGHTS.has(s.h)) score += 10;

  // Prefer -rw (common in feature graphics delivery)
  if (u.includes('-rw')) score += 3;

  // Avoid typical screenshot heights
  if (s.h === 1080 || s.h === 720 || s.h === 480) score -= 6;

  // Prefer "banner-like" scale (not too tall). If height <= 600, bonus; else slight penalty
  if (s.h <= 600) score += 2; else score -= 2;

  return score;
}

function pickFeatureGraphic(urls) {
  // Consider only play-lh images
  const candidates = urls.filter(u => u.includes(IMG_HOST));
  if (!candidates.length) return null;

  // Score all, keep the highest scoring
  let best = null;
  let bestScore = -Infinity;
  for (const u of candidates) {
    const s = scoreCandidate(u);
    if (s > bestScore) { best = u; bestScore = s; }
  }

  // If nothing scored (very unusual), fall back to first near-16:9 under 600px height
  if (!best) {
    for (const u of candidates) {
      const s = extractWH(u);
      if (s && s.w > s.h && s.ratio && s.ratio > 1.6 && s.ratio < 1.95 && s.h <= 600) { best = u; break; }
    }
  }
  return best;
}

// --- UI wiring -----------------------------------------------------------
const elInput = document.getElementById('input');
const elGo = document.getElementById('go');
const elKeep = document.getElementById('keep169');
const elStatus = document.getElementById('status');
const elRes = document.getElementById('result');
const elOut = document.getElementById('outUrl');
const elCopy = document.getElementById('copyUrl');
const elPrev = document.getElementById('preview');
const elMeta = document.getElementById('meta');
const elOpen = document.getElementById('openRaw');

function setStatus(msg, kind = 'info') {
  const colors = { info: 'text-slate-400', ok: 'text-emerald-400', err: 'text-rose-400' };
  elStatus.className = `mt-4 text-sm ${colors[kind] || colors.info}`;
  elStatus.textContent = msg || '';
}

async function extract() {
  elRes.classList.add('hidden');
  setStatus('');

  const pkg = getPackageId(elInput.value);
  if (!pkg) { setStatus('Enter a Play URL or a valid package ID.', 'err'); return; }

  const proxy = prompt("Enter proxy endpoint (ending with ?url=)");
  if (!proxy) { setStatus('Proxy endpoint required.', 'err'); return; }

  const playUrl = buildPlayUrl(pkg);
  const target = proxy.endsWith('=') ? proxy + encodeURIComponent(playUrl) : proxy + playUrl;

  setStatus('Fetching page via proxy…');
  let html = '';
  try {
    const r = await fetch(target, { method: 'GET' });
    if (!r.ok) throw new Error(`Proxy HTTP ${r.status}`);
    html = await r.text();
  } catch (e) {
    setStatus(`Fetch failed: ${e.message}`, 'err');
    return;
  }

  setStatus('Parsing images…');
  const urls = extractImageUrlsFromHtml(html);
  const feat = pickFeatureGraphic(urls);
  if (!feat) { setStatus('No feature graphic found.', 'err'); return; }

  const normalized = normalizeW1024(feat, elKeep.checked);
  elOut.value = normalized;
  elPrev.src = normalized;
  elOpen.href = normalized;

  const s = extractWH(feat);
  elMeta.textContent = s ? `Original size tokens: w${s.w}×h${s.h} (~${(s.ratio).toFixed(3)}:1)` : 'Original size tokens: unknown';

  setStatus('Done ✔', 'ok');
  elRes.classList.remove('hidden');
}

elGo.addEventListener('click', extract);
elInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') extract(); });
elCopy.addEventListener('click', async () => {
  try { await navigator.clipboard.writeText(elOut.value); elCopy.textContent = 'Copied'; setTimeout(()=> elCopy.textContent = 'Copy URL', 1000); } catch {}
});
</script>
</body>
</html>
